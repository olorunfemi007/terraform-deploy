# name: GitHub Actions Demo
# run-name: ${{ github.actor }} is testing out GitHub Actions üöÄ
# on: [push]
# jobs:
#   Explore-GitHub-Actions:
#     runs-on: ubuntu-latest
#     steps:
#       - run: echo "üéâ The job was automatically triggered by a ${{ github.event_name }} event."
#       - run: echo "üêß This job is now running on a ${{ runner.os }} server hosted by GitHub!"
#       - run: echo "üîé The name of your branch is ${{ github.ref }} and your repository is ${{ github.repository }}."
#       - name: Check out repository code
#         uses: actions/checkout@v4
#       - run: echo "üí° The ${{ github.repository }} repository has been cloned to the runner."
#       - run: echo "üñ•Ô∏è The workflow is now ready to test your code on the runner."
#       - name: List files in the repository
#         run: |
#           ls ${{ github.workspace }}
#       - run: echo "üçè This job's status is ${{ job.status }}."


# This workflow will build a Java project with Maven, and cache/restore any dependencies to improve the workflow execution time
# For more information see: https://docs.github.com/en/actions/automating-builds-and-tests/building-and-testing-java-with-maven

# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

name: Java CI with Maven

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      job_type:
        description: 'Type of TF Job'
        required: true
        default: 'apply'
        type: choice
        options:
          - apply
          - destroy

jobs:
  build:
    runs-on: ubuntu-latest
    env:
      SECRET_NAME: 'ecrpullsecret'
      DOCKER_ECR: '211125745138.dkr.ecr.us-east-1.amazonaws.com'
      DOCKER_USERNAME: 'AWS'
      DOCKER_EMAIL: 'emmidim01@gmail.com'

    steps:
    - name: Checkout Repo
      uses: actions/checkout@v4

    - name: Install kubectl
      uses: azure/setup-kubectl@v2.0
      with:
        version: 'v1.24.0' # default is latest stable

    - name: Install Terraform
      run: |
        wget -O- https://apt.releases.hashicorp.com/gpg | gpg --dearmor | sudo tee /usr/share/keyrings/hashicorp-archive-keyring.gpg
        echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
        sudo apt update && sudo apt install terraform

    - name: Terraform Init
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      run: terraform init

    # Generates an execution plan for Terraform
    - name: Terraform Plan
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      run: terraform plan -lock=false

    # On push to "main", build or change infrastructure according to Terraform configuration files
    # Note: It is recommended to set up a required "strict" status check in your repository for "Terraform Cloud".
    # See the documentation on "strict" required status checks for more information:
    # https://help.github.com/en/github/administering-a-repository/types-of-required-status-checks
    - name: Terraform Apply
      if: github.event.inputs.job_type == 'apply'
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      run: terraform apply -auto-approve -lock=false

    - name: Terraform Destroy
      if: github.event.inputs.job_type == 'destroy'
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      run: |
        terraform destroy -auto-approve -lock=false
        exit 0

    # - name: Terraform Init
    #   uses: hashicorp/terraform-github-actions/init@v0.4.0
    #   env:
    #     GITHUB_TOKEN: ${{ secrets.GIT_TOKEN }}
    #     # TF_ACTION_WORKING_DIR: 'terraform'
    #     AWS_ACCESS_KEY_ID:  ${{ secrets.AWS_ACCESS_KEY_ID }}
    #     AWS_SECRET_ACCESS_KEY:  ${{ secrets.AWS_SECRET_ACCESS_KEY }}

    # - name: Terraform Validate
    #   uses: hashicorp/terraform-github-actions/validate@v0.3.7

    # - name: Terraform Apply
    #   if: ${{github.events.input.job_type == 'apply'}}
    #   uses: hashicorp/terraform-github-actions/apply@v0.4.0
    #   env:
    #     GITHUB_TOKEN: ${{ secrets.GIT_TOKEN }}
    #     # TF_ACTION_WORKING_DIR: 'terraform'
    #     AWS_ACCESS_KEY_ID:  ${{ secrets.AWS_ACCESS_KEY_ID }}
    #     AWS_SECRET_ACCESS_KEY:  ${{ secrets.AWS_SECRET_ACCESS_KEY }}

    # - name: Terraform Destroy
    #   if: ${{github.events.input.job_type == 'destroy'}}
    #   uses: hashicorp/terraform-github-actions/destroy@v0.1.0
    #   env:
    #     GITHUB_TOKEN: ${{ secrets.GIT_TOKEN }}
    #     # TF_ACTION_WORKING_DIR: 'terraform'
    #     AWS_ACCESS_KEY_ID:  ${{ secrets.AWS_ACCESS_KEY_ID }}
    #     AWS_SECRET_ACCESS_KEY:  ${{ secrets.AWS_SECRET_ACCESS_KEY }}
    - name: Set up JDK 14
      uses: actions/setup-java@v1
      with:
        java-version: '14'
        distribution: 'temurin'
        cache: maven
    
    - name: Build with Maven
      run: mvn -B package --file pom.xml
    - name: Install with Maven
      run: mvn -B install --file pom.xml
    - name: Move WAR file to build context
      run: cp /home/runner/.m2/repository/com/fusi/tutorial/addressbook/1.0/addressbook-1.0.war .
    - name: Set up QEMU
      uses: docker/setup-qemu-action@v3
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    # - name: Login to Docker Hub
    #   uses: docker/login-action@v3
    #   with:
    #     username: ${{ secrets.DOCKERHUB_USERNAME }}
    #     password: ${{ secrets.DOCKERHUB_TOKEN }}
    # - name: Build and push to dockerhub
    #   uses: docker/build-push-action@v3
    #   with:
    #     context: .      #set build context (the directory from which the Docker build command is run, contains all necessary files, especially the WAR file.)
    #     push: true
    #     tags: femi28/maven-app:${{ github.sha }}
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-east-1

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1
    - name: Build & Push image
      uses: docker/build-push-action@v3
      with:
        context: .
        registry: ${{ steps.login-ecr.outputs.registry }}
        repository: ${{ steps.login-ecr.outputs.registry }}/java_app
        push: true
        tags: ${{ steps.login-ecr.outputs.registry }}/java_app:${{ github.sha }}
        add_git_labels: true
        tag_with_ref: true

    - name: Update kube config
      run: aws eks update-kubeconfig --region us-east-1 --name java_app_cluster

    - name: Check for Kubernetes Secret
      id: check-secret
      run: |
        NAMESPACE=default # specify the namespace

        if kubectl get secret $SECRET_NAME --namespace $NAMESPACE; then
          echo "Secret $SECRET_NAME exists"
          echo "::set-output name=secret_exists::true"
        else
          echo "Secret $SECRET_NAME does not exist"
          DOCKER_SECRET=$(aws ecr --region=us-east-1 get-authorization-token --output text --query authorizationData[].authorizationToken | base64 -d | cut -d: -f2)
          echo "Login Result: $DOCKER_SECRET"
          kubectl create secret docker-registry $SECRET_NAME --docker-server=$DOCKER_ECR --docker-username=$DOCKER_USERNAME --docker-password=$DOCKER_SECRET --docker-email=$DOCKER_EMAIL
        fi

    - name: Deploy to EKS
      run: |
        kubectl apply -f deployment/deploy.yaml 
        kubectl apply -f deployment/pod_service.yaml 
        kubectl apply -f deployment/hpa.yaml 
        kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml




          

     

